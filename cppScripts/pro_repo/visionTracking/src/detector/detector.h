#pragma once#include "../def/macro_def.h"#include "../def/type_def.h"enum MarkerType{    SWM = 0,    DWM_A,    DWM_B};class Detector{public:    Detector(const cv::Size size, const MarkerType marker_type = SWM);    CornersSorted process(const cv::Mat image);    private:    /* detect in one image */    std::tuple<CornersTemplate, bool> detectCornersRectRoi(const cv::Mat& image);    std::tuple<CornersTemplate, bool> detectCornersOnMarker();    std::tuple<cv::Mat, cv::Mat, cv::Mat> secondDerivCornerMetricRoi(const cv::Mat& img_gray);     std::tuple<Maximas, cv::Mat, cv::Mat, cv::Mat> parallelGetCandidates(const cv::Mat& img,         const int step_h = 100, const int step_w = 100);    Corner subPixelLocation(const Corner& point);    std::tuple<PixelType, PixelType> findEdgeAngles(const Corner& point, const PixelType corner_width);    std::tuple<PixelType, PixelType> edgeOrientation(const cv::Mat& img_angle, const cv::Mat& img_weight);        std::tuple<CornerTemplate, CornerTemplate, int> findFirstSecondCorners(const Corner& point);    Corners findNextCorners(const CornerTemplate& current, const PixelType search_length, int dir);    bool isMarkerCorners(CornerTemplate& checked_corner);    /* steps */    cv::Mat convertToGray(const cv::Mat& image);    Maximas nonMaximumSuppression(const cv::Mat& img, int n = 8, int margin = 8, PixelType tau = 0.06f);    std::tuple<PixelType, PixelType, PixelType> calcBolicCorrelationRefineAngle(const Corner& point, int theta_width,         PixelType theta, PixelType phi, const Eigen::Vector2f search_vect = Eigen::Vector2f(0.0, 0.0));    PixelType calcBolicCorrelation(const Corner& point, int theta_width, PixelType theta, PixelType phi,         const Eigen::Vector2f search_vect = Eigen::Vector2f(0.0, 0.0));        CornerTemplate predictNextCorner(const CornerTemplate& current, const PixelType search_length, int dir);    #ifdef USE_CUDA    void initCuda(const cv::Size& size);    std::tuple<cv::Mat, cv::Mat, cv::Mat> secondDerivCornerMetricCuda();#endif    /* others */    Eigen::MatrixXf calcPatchX();private:    const cv::Size SIZE;    const int SIGMA;    const int HALF_PATCH_SIZE;    const Eigen::MatrixXf PATCH_X;    const int WIDTH_MIN;    const PixelType CORR_THRESHOLD;    const int MIN_NUM_ONE_START;    const int MIN_NUM_FIRST_EXIT;    const int MIN_NUM_EXIT;    const int ROI_WIDTH_RATE;    const PixelType NMS_THRESHOLD_SIGMA_2;    const int TRY_FIRST_WIDTH_MAX;    const PixelType EXPAND_RATE;    const int MAX_TEMPLATE_WIDTH;    DetectRectangle rect;    int unfound_count;    PixelType first_ang1;     PixelType first_ang2;    int try_first_width;    Maximas corner_candidates;    cv::Mat gray_image;    cv::Mat I_angle;    cv::Mat I_weight;    cv::Mat cmax_sigma_2;    const MarkerType marker_type;#ifdef USE_CUDA    cv::Ptr<cv::cuda::Filter> filter_dx, filter_dy, filter_G;    cv::cuda::GpuMat g_ones, g_zeros;#endif};