#pragma once#include "opencv2/opencv.hpp"#include <vector>#include <Eigen/Core>using PixelType = float;const PixelType PI = CV_PI;const int MatType = CV_32FC1;struct Maxima{	Maxima(int i, int j, PixelType val)		: corner(i, j), val(val)	{}	cv::Point corner;	PixelType val;};using Maximas = std::vector<Maxima>;using WeightPoints = std::vector<Maxima>;using Corner = cv::Point_<PixelType>;using Corners = std::vector<Corner>;struct CornerSorted{	CornerSorted()		: point(0, 0), sepeNum(0)	{}	CornerSorted(int i, int j)		: point(i, j), sepeNum(0)	{}	Corner point;	int sepeNum;};using CornersSorted = std::vector<CornerSorted>;struct CornerTemplate{	CornerTemplate(const Corner& point, int width)		: point(point), width(width), angle1(0), angle2(0), 		search_angle(0), corr(-1), sepeNum(0)/*, firstIdx(0.0)*/	{}	Corner point;	PixelType width;	PixelType angle1;	PixelType angle2; //angle2 > angle1	PixelType search_angle;	PixelType corr;	int sepeNum;};using CornersTemplate = std::vector<CornerTemplate>;struct DetectRectangle{	bool is_full(const cv::Size& size) const	{		if (range_x.start == 0 && range_x.end == size.width &&			range_y.start == 0 && range_y.end == size.height)		{			return true;		}		return false;	}	cv::Range range_x;	cv::Range range_y;};struct PatternCorners{	PatternCorners()		:axial_idx(0), max_cl_val(-100), center_(Corner())	{}	int axial_idx;	Corners corners_;	std::vector<Eigen::Vector3d> points_;	cv::Mat pattern_roi;	Corner center_;	double max_cl_val;};